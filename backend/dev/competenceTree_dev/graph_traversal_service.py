"""
Service de travers√©e du graphe ESCO en utilisant GraphSAGE.

Ce service permet de traverser le graphe ESCO √† partir de n≈ìuds d'ancrage
en utilisant le mod√®le GraphSAGE pour calculer les similarit√©s entre les n≈ìuds.
"""

import os
import logging
import torch
import numpy as np
import networkx as nx
from typing import List, Dict, Any, Optional, Tuple, Set
from pathlib import Path
import json
import pickle
from collections import defaultdict, deque
import sys

# Configuration du logger early
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Production-grade path resolution for Railway deployment compatibility
def get_production_paths():
    """Get correct paths for both local development and Railway deployment."""
    current_file = os.path.abspath(__file__)
    
    # Try Railway deployment paths first
    railway_paths = {
        'backend': '/app',
        'services': '/app/app/services', 
        'gnn': '/app/app/services/GNN',
        'model': '/app/app/services/GNN/best_model_20250520_022237.pt',
        'data_dir': '/app/app/data'  # Moved from /app/dev which might not deploy
    }
    
    # Check if we're in Railway environment
    if os.path.exists('/app/main_deploy.py'):
        return railway_paths
    
    # Local development paths
    local_backend = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    local_paths = {
        'backend': local_backend,
        'services': os.path.join(local_backend, "app", "services"),
        'gnn': os.path.join(local_backend, "app", "services", "GNN"),
        'model': os.path.join(local_backend, "app", "services", "GNN", "best_model_20250520_022237.pt")
    }
    
    return local_paths

# Get production paths
PATHS = get_production_paths()

# Import GraphSAGE model safely with multiple fallback paths
graphsage_model = None
CareerTreeModel = None

try:
    # Try importing from services/GNN first
    sys.path.insert(0, PATHS['services'])
    from GNN.GraphSage import GraphSAGE, CareerTreeModel
    graphsage_model = GraphSAGE
    logger.info("‚úÖ GraphSAGE import√© depuis app/services/GNN")
except ImportError as e:
    logger.warning(f"‚ùå Impossible d'importer GraphSAGE depuis services/GNN: {e}")
    
    try:
        # Fallback: Try importing from local GNN path
        sys.path.insert(0, PATHS['gnn'])
        from GraphSage import GraphSAGE, CareerTreeModel
        graphsage_model = GraphSAGE
        logger.info("‚úÖ GraphSAGE import√© depuis chemin GNN local")
    except ImportError as e2:
        logger.error(f"‚ùå Impossible d'importer GraphSAGE depuis tous les chemins: {e2}")
        logger.info("Le service fonctionnera en mode fallback sans GraphSAGE")

class GraphTraversalService:
    """
    Service de travers√©e du graphe ESCO utilisant GraphSAGE pour les calculs de similarit√©.
    
    Ce service :
    1. Charge un graphe ESCO pr√©trait√©
    2. Utilise un mod√®le GraphSAGE entra√Æn√© pour calculer les similarit√©s
    3. Permet la travers√©e intelligente du graphe bas√©e sur les embeddings
    4. Supporte les requ√™tes de similarit√© entre n≈ìuds
    """
    
    def __init__(self):
        """Initialise le service de travers√©e du graphe."""
        self.graph = None
        self.node_metadata = {}
        self.graphsage_model = None
        self.model_loaded = False
        self.graph_loaded = False
        
        # Tenter de charger le graphe et le mod√®le
        self._load_graph()
        self._load_graphsage_model()
    
    def _load_graph(self):
        """Charge le graphe ESCO depuis les fichiers de donn√©es."""
        try:
            # Chercher les fichiers de graphe dans diff√©rents emplacements
            possible_graph_files = [
                os.path.join(PATHS.get('data_dir', PATHS['backend']), 'esco_graph.pkl'),
                os.path.join(PATHS['backend'], 'data', 'esco_graph.pkl'),
                os.path.join(PATHS['backend'], 'app', 'data', 'esco_graph.pkl'),
                os.path.join(PATHS['backend'], 'dev', 'competenceTree_dev', 'esco_graph.pkl')
            ]
            
            graph_file = None
            for file_path in possible_graph_files:
                if os.path.exists(file_path):
                    graph_file = file_path
                    break
            
            if graph_file:
                with open(graph_file, 'rb') as f:
                    graph_data = pickle.load(f)
                    self.graph = graph_data.get('graph', nx.Graph())
                    self.node_metadata = graph_data.get('metadata', {})
                
                logger.info(f"‚úÖ Graphe ESCO charg√© depuis {graph_file}")
                logger.info(f"üìä Graphe: {self.graph.number_of_nodes()} n≈ìuds, {self.graph.number_of_edges()} ar√™tes")
                self.graph_loaded = True
            else:
                logger.warning("‚ùå Aucun fichier de graphe ESCO trouv√©, cr√©ation d'un graphe vide")
                self._create_fallback_graph()
                
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du chargement du graphe: {e}")
            self._create_fallback_graph()
    
    def _create_fallback_graph(self):
        """Cr√©e un graphe de fallback minimal pour les tests."""
        self.graph = nx.Graph()
        self.node_metadata = {}
        
        # Ajouter quelques n≈ìuds d'exemple pour √©viter les erreurs
        sample_nodes = [
            ("occupation_1", {"type": "occupation", "preferredLabel": "Software Developer"}),
            ("skill_1", {"type": "skill", "preferredLabel": "Programming"}),
            ("skill_2", {"type": "skill", "preferredLabel": "Problem Solving"}),
            ("skill_3", {"type": "skill", "preferredLabel": "Critical Thinking"})
        ]
        
        for node_id, metadata in sample_nodes:
            self.graph.add_node(node_id)
            self.node_metadata[node_id] = metadata
        
        # Ajouter quelques ar√™tes d'exemple
        self.graph.add_edge("occupation_1", "skill_1")
        self.graph.add_edge("occupation_1", "skill_2")
        self.graph.add_edge("skill_1", "skill_3")
        
        logger.info("‚úÖ Graphe de fallback cr√©√© avec des donn√©es d'exemple")
        self.graph_loaded = True
    
    def _load_graphsage_model(self):
        """Charge le mod√®le GraphSAGE pr√©-entra√Æn√©."""
        if not graphsage_model or not CareerTreeModel:
            logger.warning("‚ùå Classes GraphSAGE non disponibles, mode fallback activ√©")
            return
        
        try:
            model_path = PATHS['model']
            
            if not os.path.exists(model_path):
                logger.warning(f"‚ùå Mod√®le GraphSAGE non trouv√©: {model_path}")
                logger.info("Le service fonctionnera avec des similarit√©s basiques")
                return
            
            # Cr√©er une instance du mod√®le complet
            full_model = CareerTreeModel(
                input_dim=1024,
                hidden_dim=128,
                output_dim=128,
                dropout=0.2
            )
            
            # Charger le checkpoint
            checkpoint = torch.load(model_path, map_location='cpu', weights_only=False)
            
            if 'model_state_dict' not in checkpoint:
                logger.error("‚ùå Checkpoint invalide: 'model_state_dict' manquant")
                return
            
            # Charger les poids
            full_model.load_state_dict(checkpoint['model_state_dict'])
            full_model.eval()
            
            # Extraire seulement l'encodeur (GraphSAGE)
            self.graphsage_model = full_model.encoder
            self.graphsage_model.eval()
            
            logger.info("‚úÖ Mod√®le GraphSAGE charg√© avec succ√®s")
            self.model_loaded = True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du chargement du mod√®le GraphSAGE: {e}")
            logger.info("Le service fonctionnera avec des similarit√©s basiques")
    
    def get_node_neighbors(self, node_id: str, max_neighbors: int = 10) -> List[Dict[str, Any]]:
        """
        R√©cup√®re les voisins directs d'un n≈ìud.
        
        Args:
            node_id: ID du n≈ìud source
            max_neighbors: Nombre maximum de voisins √† retourner
            
        Returns:
            Liste des voisins avec leurs m√©tadonn√©es
        """
        if not self.graph_loaded or node_id not in self.graph:
            return []
        
        neighbors = []
        for neighbor_id in list(self.graph.neighbors(node_id))[:max_neighbors]:
            neighbor_data = {
                'id': neighbor_id,
                'metadata': self.node_metadata.get(neighbor_id, {}),
                'similarity': 1.0  # Similarit√© maximale pour les voisins directs
            }
            neighbors.append(neighbor_data)
        
        return neighbors
    
    def compute_node_similarity(self, node_id1: str, node_id2: str) -> float:
        """
        Calcule la similarit√© entre deux n≈ìuds.
        
        Args:
            node_id1: Premier n≈ìud
            node_id2: Deuxi√®me n≈ìud
            
        Returns:
            Score de similarit√© entre 0 et 1
        """
        if not self.graph_loaded:
            return 0.0
        
        if node_id1 not in self.graph or node_id2 not in self.graph:
            return 0.0
        
        if node_id1 == node_id2:
            return 1.0
        
        # Si le mod√®le GraphSAGE est disponible, l'utiliser
        if self.model_loaded and self.graphsage_model:
            try:
                return self._compute_graphsage_similarity(node_id1, node_id2)
            except Exception as e:
                logger.warning(f"‚ùå Erreur GraphSAGE, fallback vers similarit√© basique: {e}")
        
        # Fallback: utiliser la similarit√© bas√©e sur les voisins communs
        return self._compute_basic_similarity(node_id1, node_id2)
    
    def _compute_graphsage_similarity(self, node_id1: str, node_id2: str) -> float:
        """
        Calcule la similarit√© en utilisant les embeddings GraphSAGE.
        
        Args:
            node_id1: Premier n≈ìud
            node_id2: Deuxi√®me n≈ìud
            
        Returns:
            Score de similarit√© GraphSAGE
        """
        # TODO: Impl√©menter le calcul r√©el avec GraphSAGE
        # Pour l'instant, retourner une similarit√© basique
        return self._compute_basic_similarity(node_id1, node_id2)
    
    def _compute_basic_similarity(self, node_id1: str, node_id2: str) -> float:
        """
        Calcule une similarit√© basique bas√©e sur les voisins communs.
        
        Args:
            node_id1: Premier n≈ìud
            node_id2: Deuxi√®me n≈ìud
            
        Returns:
            Score de similarit√© basique
        """
        try:
            # Voisins directs
            neighbors1 = set(self.graph.neighbors(node_id1))
            neighbors2 = set(self.graph.neighbors(node_id2))
            
            # Calcul de l'indice de Jaccard
            intersection = len(neighbors1.intersection(neighbors2))
            union = len(neighbors1.union(neighbors2))
            
            if union == 0:
                return 0.0
            
            jaccard_similarity = intersection / union
            
            # V√©rifier s'ils sont directement connect√©s (bonus)
            if self.graph.has_edge(node_id1, node_id2):
                jaccard_similarity = min(1.0, jaccard_similarity + 0.3)
            
            # V√©rifier le m√™me type (bonus l√©ger)
            type1 = self.node_metadata.get(node_id1, {}).get('type', '')
            type2 = self.node_metadata.get(node_id2, {}).get('type', '')
            if type1 == type2 and type1:
                jaccard_similarity = min(1.0, jaccard_similarity + 0.1)
            
            return jaccard_similarity
            
        except Exception as e:
            logger.error(f"‚ùå Erreur calcul similarit√© basique: {e}")
            return 0.0
    
    def find_similar_nodes(self, 
                          node_id: str, 
                          node_type: Optional[str] = None,
                          max_results: int = 10,
                          min_similarity: float = 0.1) -> List[Dict[str, Any]]:
        """
        Trouve les n≈ìuds similaires √† un n≈ìud donn√©.
        
        Args:
            node_id: ID du n≈ìud de r√©f√©rence
            node_type: Type de n≈ìuds √† chercher (optionnel)
            max_results: Nombre maximum de r√©sultats
            min_similarity: Seuil minimum de similarit√©
            
        Returns:
            Liste des n≈ìuds similaires tri√©s par similarit√© d√©croissante
        """
        if not self.graph_loaded or node_id not in self.graph:
            return []
        
        similar_nodes = []
        
        # Parcourir tous les n≈ìuds du graphe
        for candidate_id in self.graph.nodes():
            if candidate_id == node_id:
                continue
            
            # Filtrer par type si sp√©cifi√©
            if node_type:
                candidate_type = self.node_metadata.get(candidate_id, {}).get('type', '')
                if candidate_type != node_type:
                    continue
            
            # Calculer la similarit√©
            similarity = self.compute_node_similarity(node_id, candidate_id)
            
            if similarity >= min_similarity:
                similar_nodes.append({
                    'id': candidate_id,
                    'similarity': similarity,
                    'metadata': self.node_metadata.get(candidate_id, {}),
                    'type': self.node_metadata.get(candidate_id, {}).get('type', 'unknown')
                })
        
        # Trier par similarit√© d√©croissante et limiter les r√©sultats
        similar_nodes.sort(key=lambda x: x['similarity'], reverse=True)
        return similar_nodes[:max_results]
    
    def traverse_graph(self, 
                      start_node: str,
                      max_depth: int = 3,
                      max_nodes_per_level: int = 5,
                      node_types: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Traverse le graphe √† partir d'un n≈ìud de d√©part.
        
        Args:
            start_node: N≈ìud de d√©part
            max_depth: Profondeur maximale de travers√©e
            max_nodes_per_level: Nombre maximum de n≈ìuds par niveau
            node_types: Types de n≈ìuds √† inclure (optionnel)
            
        Returns:
            Structure hi√©rarchique de la travers√©e
        """
        if not self.graph_loaded or start_node not in self.graph:
            return {"error": "N≈ìud de d√©part invalide ou graphe non charg√©"}
        
        visited = set()
        result = {
            "start_node": start_node,
            "levels": [],
            "total_nodes": 0
        }
        
        current_level = [start_node]
        visited.add(start_node)
        
        for depth in range(max_depth):
            level_nodes = []
            next_level = []
            
            for node_id in current_level:
                # Ajouter le n≈ìud actuel au niveau
                node_data = {
                    "id": node_id,
                    "metadata": self.node_metadata.get(node_id, {}),
                    "depth": depth
                }
                level_nodes.append(node_data)
                
                # Trouver les voisins pour le niveau suivant
                neighbors = self.get_node_neighbors(node_id, max_nodes_per_level * 2)
                neighbor_scores = []
                
                for neighbor in neighbors:
                    neighbor_id = neighbor['id']
                    
                    if neighbor_id in visited:
                        continue
                    
                    # Filtrer par type si sp√©cifi√©
                    if node_types:
                        neighbor_type = neighbor['metadata'].get('type', '')
                        if neighbor_type not in node_types:
                            continue
                    
                    # Calculer la similarit√© pour le tri
                    similarity = self.compute_node_similarity(node_id, neighbor_id)
                    neighbor_scores.append((neighbor_id, similarity))
                
                # Trier les voisins par similarit√© et prendre les meilleurs
                neighbor_scores.sort(key=lambda x: x[1], reverse=True)
                for neighbor_id, _ in neighbor_scores[:max_nodes_per_level]:
                    if neighbor_id not in visited:
                        next_level.append(neighbor_id)
                        visited.add(neighbor_id)
                        
                        if len(next_level) >= max_nodes_per_level:
                            break
                
                if len(next_level) >= max_nodes_per_level:
                    break
            
            result["levels"].append(level_nodes)
            result["total_nodes"] += len(level_nodes)
            
            if not next_level:
                break
                
            current_level = next_level[:max_nodes_per_level]
        
        return result
    
    def get_node_info(self, node_id: str) -> Optional[Dict[str, Any]]:
        """
        R√©cup√®re les informations d√©taill√©es d'un n≈ìud.
        
        Args:
            node_id: ID du n≈ìud
            
        Returns:
            Informations du n≈ìud ou None si non trouv√©
        """
        if not self.graph_loaded or node_id not in self.graph:
            return None
        
        neighbors = list(self.graph.neighbors(node_id))
        metadata = self.node_metadata.get(node_id, {})
        
        return {
            "id": node_id,
            "metadata": metadata,
            "type": metadata.get("type", "unknown"),
            "label": metadata.get("preferredLabel", metadata.get("label", node_id)),
            "neighbor_count": len(neighbors),
            "neighbors": neighbors[:10],  # Limiter √† 10 pour l'affichage
            "degree": self.graph.degree(node_id)
        }
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        R√©cup√®re les statistiques du graphe et du service.
        
        Returns:
            Dictionnaire des statistiques
        """
        stats = {
            "graph_loaded": self.graph_loaded,
            "model_loaded": self.model_loaded,
            "nodes_count": 0,
            "edges_count": 0,
            "node_types": {},
            "graphsage_available": self.graphsage_model is not None
        }
        
        if self.graph_loaded and self.graph:
            stats["nodes_count"] = self.graph.number_of_nodes()
            stats["edges_count"] = self.graph.number_of_edges()
            
            # Compter les types de n≈ìuds
            type_counts = {}
            for node_id in self.graph.nodes():
                node_type = self.node_metadata.get(node_id, {}).get('type', 'unknown')
                type_counts[node_type] = type_counts.get(node_type, 0) + 1
            
            stats["node_types"] = type_counts
        
        return stats

# Fonction utilitaire pour cr√©er une instance globale
_graph_service_instance = None

def get_graph_service() -> GraphTraversalService:
    """
    R√©cup√®re l'instance globale du service de travers√©e du graphe.
    
    Returns:
        Instance du GraphTraversalService
    """
    global _graph_service_instance
    if _graph_service_instance is None:
        _graph_service_instance = GraphTraversalService()
    return _graph_service_instance

# Test des fonctionnalit√©s si ex√©cut√© directement
if __name__ == "__main__":
    print("üß™ Test du service de travers√©e du graphe ESCO")
    print("=" * 60)
    
    # Cr√©er une instance du service
    service = GraphTraversalService()
    
    # Afficher les statistiques
    stats = service.get_statistics()
    print(f"üìä Statistiques du service:")
    for key, value in stats.items():
        print(f"   {key}: {value}")
    print()
    
    # Tester avec les n≈ìuds d'exemple
    if service.graph_loaded:
        # Lister quelques n≈ìuds
        sample_nodes = list(service.graph.nodes())[:3]
        print(f"üîç N≈ìuds d'exemple: {sample_nodes}")
        
        if sample_nodes:
            test_node = sample_nodes[0]
            print(f"\nüß™ Test avec le n≈ìud: {test_node}")
            
            # Informations du n≈ìud
            node_info = service.get_node_info(test_node)
            print(f"‚ÑπÔ∏è  Informations: {node_info}")
            
            # Voisins
            neighbors = service.get_node_neighbors(test_node, max_neighbors=3)
            print(f"üë• Voisins: {[n['id'] for n in neighbors]}")
            
            # N≈ìuds similaires
            similar = service.find_similar_nodes(test_node, max_results=3)
            print(f"üîÑ Similaires: {[(s['id'], f\"{s['similarity']:.2f}\") for s in similar]}")
            
            # Travers√©e
            traversal = service.traverse_graph(test_node, max_depth=2, max_nodes_per_level=2)
            if "error" not in traversal:
                print(f"üåê Travers√©e: {traversal['total_nodes']} n≈ìuds sur {len(traversal['levels'])} niveaux")
            else:
                print(f"‚ùå Erreur travers√©e: {traversal['error']}")
    
    print("\n‚úÖ Test termin√©")